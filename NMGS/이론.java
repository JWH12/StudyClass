package NMGS;

public class 이론 {
	
	/*
	
	================== 1. Scanner  (완료) ==================
	
	Scanner 클래스를 이용하여 키보드로 입력을 받는다.
	
	Scanner s = new Scanner(System.in);  → Scanner이라는 클래스를 이용하여 객체를 생성한다
	
	int num = s.nextInt(); → 키보드로 입력된 숫자 값을 가져온다.
	
	s.nextInt(); → 정수 입력 가능
	s.nextLine()l → 문자 입력 가능
	  
	  
	================== 2. 향상된 for문  (완료) ==================
	
	향상된 for문은 배열만을 이용할 수 있다.
	 
	 
	 
	 ====================== Object =============================
	 	 
	=> Object클래스가 자바에서 '최상의 클래스'이다.	Object클래스에는 다양한 메소드가 존재하는데, 어떤 클래스에서도 이 메소드를 호출할수있다.
	
	=> Object 클래스의 대표적인 메소드는 equals(), hashCode(), toString() 메소드가 있다.
	
		- equals() 메소드 : 두 객체가 동일한 객체라면 true를 리턴하고, 다르다면 false를 리턴합니다.
		
		- hashCode() 메소드 : 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴한다.
		객체마다 다른값을 가지고 있다.
		
		- toString() 메소드 : 객체의 문자 정보를 리턴한다. 즉, 객체를 문자열로 표현한다.  
	 
	 
	 
	 
	================== 7. 클래스 구성 중 상속 및 return ==================


	7-1. 인스턴스 → 어떤 클래스로부터 객체를 만드는 과정
	
	
	7-2. 필드 (참고자료 https://kephilab.tistory.com/46)
	=> 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
	=> 생성자와 메소드 전체에 사용되며 객체가 소멸되지 않는 한 함꼐 존재한다.
	=> 생성자와 메소드 중괄호 내부에 선언된 것은 모두 로컬 변수가 된다.(필드라고 하지 않는다)
	 
	 
	 ================== instanceof =================================
	 
	 => instanceof는 객체 타입을 확인하는 연산자이다. 즉  instancof는 해당 클래스가 자기집이 맞는지 확인해 주는 것

	 => 형변환 가능 여부를 확인하며 true / false로 결과를 반환한다.

	 => 주로 상속 관계에서 부모객체인지 자식 객체인지 확인하는 데 사용된다.
	 
	 
	 
	 ========================== 객체배열 ===============================
	 
	 3. 객체 배열
	  => 객체를 저장하는 배열로 배열의 자료형을 클래스명(사용자 정의 자료형)으로 지정하여 활용
	 
	  => 객체배열의 선언과 동시에 할당한다. ex) 클래스명 배열명[] = new 클래스명[배열크기];
	  
	  => 객체배열의 호출의 경우 자료에 접근할 때는 인덱스를 활용하여 접근한다.
	     변수명 [인덱스]로 객체에 접근하고 멤버변수나 메소드에 접근하려면 . 을 이용하여 접근한다.
			 
			 
			 
	 
	 ============================= static ==============================
	 
	 5. static
	  => Static이라는 키워드를 사용하여 Static변수와 Static메소드를 만들 수 있는데 다른말로 정적필드와 정적 메소드라고도 하며 이 둘을 합쳐 정적 멤버라고 합니다.
	
	5-1 정적 필드
	  => 정적 변수는 모든 인스턴스가 하나의 저장공간을 공유하기에 항상 같은 값을 가진다.
	
	5-2 정적 메소드
	  => 정적 메소드는 클래스가 메모리에 올라갈 때 정적 메소드가 자동적으로 생성됩니다. 그렇기에 정적 메소드는 인스턴스를 생성하지 않아도 호출을 할 수 있습니다. 
	     정적 메소드는 유틸리티 함수를 만드는데 유용하게 사용됩니다.
	 
	 
	 ※ 주의할 점
	 
	  static 메소드는 오직 static멤버만 접근 가능

	   => static메소드도 static멤버와 로드되는 시점이 동일하기 때문에 객체가 생성되지 않은 상황에서도 변수를 사용할 수 있어야 한다.

	  this 키워드 사용 불가

	   => this는 호출 당시 실행 중인 객체를 가리키는 레퍼런스인데 static메소드는 객체가 생성되지 않은 상황에서도 호출이 가능하기 때문이다.


	 
	 
	 ============================ toString() ============================
	 => toString메서드는 객체가 가지고 있는 정보나 값들을 문자열로 만들어 리턴하는 메소드 입니다.
     => "String" 클래스나 "File"클래스에서는 "toString"에 메소드를 재정의 하여 의미있는 값을 리턴해 줍니다.
	 => toString() 메소드는 자동으로 호출된다
	 => ★ 클래스에서 오버라이딩(재정의)을 무조건 해줘야 한다.
	 
	 
	 
	 
	 
	 ============================ 객체 치환 ===============================
	 => 동일한 클래스의 객체끼리는 치환이 가능합니다. "치환이 가능하다."는 것은, 할당 연산자를 통해 멤버 값을 복사하는 것이 가능하다는 뜻입니다.
	
	 ex) Circle c1; // Circle이라는 클래스가 있다고 가정한다.
		 Circle c2;
		 c1 = c2; // 동일한 클래스임으로 가능하다. c2을 c1으로, 비트 단위 복사한다. 
	
	 
	 
	 
	 
	 
	 
	 ========================== final ====================================
	 => 클래스나 변수에 final을 붙이면 처음 정의된 상태가 변하지 않는 것을 보장한다는 의미이다.

	 7-1 final 변수
	 => final 키워드가 붙은 변수는 초기화 후 변경할 수 없다. 다음과 같이 변경하려고 하면 컴파일 에러가 발생한다.
	
	 7-2 final 클래스
	 => 클래스에 final을 붙이면 다른 클래스가 상속할 수 없는 클래스가 된다. 다음과 같이 final 클래스를 상속하려고 하면 컴파일 에러 발생.
	
	 7-3 final 메소드
	 => final 메소드는 Override가 안되도록 한다
		 
	 
	 
	 	 
	 	 
	 
	================================ 8. 생성자 ==============================
	 
	 => 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다.
	 => new 연산자로 호출되는 특별한 중괄호 {} 블록이다.
	 => 생성자를 실행시키지 않고는 클래스로 부터 객체를 만들 수 없다.
	 => 객체 생성 시 초기화를 담당한다.
	   (객체 초기화 : 필드를 초기화 하거나, 메소드를 호출해서 객체를 사용 할 준비를 하는 것)
	 => 클래스 이름으로 되어 있고, 반환(return) 타입이 없다.
	  
	  
	  	  
	  	  
	  
	  
	  ============================= 9.컴파일러 (완료) ====================================
	  
	  => 자바 컴파일러는 자바를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환합니다.
     	 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치됩니다.
	  
	  
	   9-1. 바이트 코드 (완료)
		 => 자바 바이트 코드(Java bytecode)란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미합니다.
	        자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있습니다.
	     	이러한 자바 바이트 코드의 확장자는 .class입니다.
	  
	  
	  
	  
	  ============================= 10.new 연산자 ====================================

	    => 클래스 객체 변수 = new 클래스();
		=> new는 클래스 타입의 인스턴스(객체)를 생성해주는 역할을 담당한다. 
		=> new 연산자로 생성된 객체는 똑같은 값을 가지고 있는 객체가 있어도 서로 다른 메모리를 할당하기
     	   때문에 서로 다른 객체로 분류된다.
		(참조 : https://gallery-k.tistory.com/category/%EC%BB%B4%ED%93%A8%ED%84%B0/Java?page=2)
	  
	  
	  
	  
	  ============================= 캐스팅 ====================================
	  
	   => 캐스팅이란 타입을 변환하는 것을 말하며 형변환이라고도 한다. 자바의 상속 관계에 있는 부모와 자식 클래스 간에는 서로 간의 형변환이 가능하다.
    
	     8-1. 업캐스팅
	       => 자식 클래스의 객체가 부모 클래스 타입으로 형변환 되는 것
		
		
	     8-2. 다운캐스팅
		   => 업캐스팅된 것을 다시 원상태로 돌리는 것을 말한다.  하위 클래스로의 다운캐스팅을 할때는 타입을 명시적으로 지정해줘야한다는 특징이 있다
		    	  
		    	  
		    	  
	  
	   ============================= 동적바인딩, 정적바인딩 ====================================
	   
	   
	    14-1 동적
		->  변수에 얼마든 자료형의 값을 넣을 수 있는 것  ex) 인터프리터 언어(자바스크립트, 파이썬)
		
		14-2 정적
		-> 변수 등에 지전된 자료형을 바꿀수 없는 것 ex) 컴파일 언어(자바)
		-> 개발과정에서 컴파일이라는 과정을 거치기 때문에 코드나 문법상 오류를 잡을 수 있다.
		    ex) 변수나 인자의 자료형이 달라지는 경우 
	   
	   
	   
	  
	  
	  ============================= 35. equals() ====================================
	  
	  => 두개의 문자열의 값을 비교하여 동일한지 판별한다
	  => 문자열을 비교할때는 정확한 판단을 위해서 무조건 equals()를 사용한다.
	  
	     ex) String str1 = "Hello";
	  		 String str2 = "Hello";	
	  		
	  		if(str1.equals(str2){}
	  		System.out.println("같다");
	  
	  		} else {
	  		
	  			System.out.println("다르다");
	  		}
	  
	  		값 : 같다
	  
	  
	 
	  
	  
	  	============================= next() 와 nextline() 의 차이  ====================================
	  
	  	next 는 문자열만 처리를 한다.
	  		
		nextline 은 공백까지 처리한다.
	  
	  
	  
	  
	  
	  
	  
	  
	 */
	
	
	

}
